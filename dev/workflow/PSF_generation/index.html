<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PSF calculation · PSFs Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PSFs Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">PSFs.jl</a></li><li><span class="tocitem">Workflow</span><ul><li><a class="tocitem" href="../PSF_parameters/">PSF parameters</a></li><li class="is-active"><a class="tocitem" href>PSF calculation</a></li></ul></li><li><span class="tocitem">Function references</span><ul><li><a class="tocitem" href="../../function_references/all_functions/">List of Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Workflow</a></li><li class="is-active"><a href>PSF calculation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PSF calculation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RainerHeintzmann/PSFs.jl/blob/main/docs/src/workflow/PSF_generation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PSF-calculation"><a class="docs-heading-anchor" href="#PSF-calculation">PSF calculation</a><a id="PSF-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#PSF-calculation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PSFs.psf" href="#PSFs.psf"><code>PSFs.psf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">psf(::Type{ModeWidefield}, sz::NTuple, pp::PSFParams; sampling=get_sampling(sz, pp))</code></pre><p>calculates the widefield single-frequency point spread function (psf), i.e. the image of a single (very small) emitter. Most of the parameters (such as refractive index, numerical aperture, vacuum wavelength, aberrations etc.) are hidden in the parameter structure argument <code>pp</code>, which should be generated via the <code>PSFParams()</code> constructor. See `<code>PSFParams()</code> for details.</p><p>#Parameters</p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp</code>:         PSF parameters of the PSF. See <code>PSFParams()</code> for details. The argument <code>pp.aplanatic</code> defined whether an excitation or emission PSF is calculated.</li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF. If <code>nothing</code> is provided, the PSF will be sampled according to the Abbe limit.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the amplitudes are calculated on a twice coarser grid and the result is upsampled. This increases the speed but may be less accurate.</li><li><code>return_amp=false</code>:    Has to be <code>false</code> since confocal amplitude spread functions do not exist for non-zero pinhole sizes. </li></ul><p>See also:</p><ul><li>apsf():  calculates the underlying amplitude point spread function (apsf)</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; pp = PSFParams(0.5,1.4,1.52); sz=(128,128,128); sampling=(0.050,0.050,0.200);
# an emission PSF of an isotropic (freely rotating emitter)
julia&gt; p_wf = psf(sz, pp; sampling=sampling);
# an emission PSF of an emitter oriented along the Z direction
julia&gt; pp_dipole = PSFParams(0.5,1.4,1.52; transition_dipole=[0.0,0.0,1.0]);
julia&gt; p_dipole = psf(sz, pp_dipole; sampling=sampling);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PSFs.jl/blob/27e86deac40a0fc160f728e14562bc139455fc87/src/PSFs.jl#L19-L46">source</a></section><section><div><pre><code class="nohighlight hljs">psf(::Type{ModeConfocal}, sz::NTuple, pp_em::PSFParams; pp_ex=nothing, pinhole=nothing, pinhole_ft=disc_pinhole_ft, sampling=nothing, use_resampling=true, return_amp=false, pinhole_positions=[(0.0,0.0)]) # unclear why the resampling seems to be so bad
Calculates a confocal point spread function. The normalisation is such that a completely open `pinhole` diameter yields the excitation PSF with its normalization. 
Returns the PSF or a vector of PSFs.</code></pre><p>#Parameters</p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. PSF parameters of the PSF. See <code>PSFParams()</code> for details. This should include the emission wavelength</li><li><code>pp_ex=nothing</code>:      This is a required named parameter, containing all the settings for the excitation PSF. This should include the excitation wavelength as well as typically <code>aplanatic=aplanatic_illumination</code>.</li><li><code>pinhole=nothing</code>:    The diameter of the pinhole in Airy Units (AU = 1.22 λ/NA). A pinhole size of one AU corresponds to a pinhole border falling onto the first zero of a corresponding paraxial emission PSF.</li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due to undersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.</li><li><code>return_amp=false</code>:    Has to be <code>false</code> since confocal amplitude spread functions do not exist for non-zero pinhole sizes. </li><li><code>pinhole_positions=[(0.0,0.0)]</code>:  A list of pinhole positions. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.</li><li><code>pinhole_ft=disc_pinhole_ft</code>:  Specifies which function is used to calculate the Fourier transform of the pinhole. This allows the user to control the pinhole shape. </li><li><code>pinhole_positions=[(0.0,0.0)]</code>:  Specifies the precise position(s) of the pinholes in the detection path. This allows to simulate an offset (misadjusted) pinhole, or (as a vector of tuples) a PSF for a whole set of positions. See the <code>psf(ModeISM, ...)</code> for more details. </li><li><code>ex2p</code>:   If <code>true</code>, the excitation PSF is locally squared to calculate a two-photon confocal PSF. However, you should typically use the <code>Mode2Photon</code> to do this. Note that the order of the PSFParams are reversed.</li></ul><pre><code class="language-jdoctest hljs">julia&gt; pp_em = PSFParams(0.5,1.4,1.52; mode=ModeConfocal);
julia&gt; pp_ex = PSFParams(pp_em; λ=0.488, aplanatic=aplanatic_illumination);
julia&gt; p_conf = psf((128,128,128),pp_em; pp_ex=pp_ex, pinhole=0.1, sampling=(0.040,0.040,0.100));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PSFs.jl/blob/27e86deac40a0fc160f728e14562bc139455fc87/src/PSFs.jl#L63-L86">source</a></section><section><div><pre><code class="nohighlight hljs">psf(::Type{ModeISM}, sz::NTuple, pp_em::PSFParams; pinhole=nothing, sampling=nothing, pinhole_ft=box_pinhole_ft, pinhole_positions=nothing, pinhole_dist=0.5, pinhole_grid=(5,5), ism_pos=ism_positions_rect, args...)
Calculates a confocal point spread function. The normalisation is such that a completely open `pinhole` diameter yields the excitation PSF with its normalization. 
Returns the PSF or a vector of PSFs.</code></pre><p>#Parameters</p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. This should include the emission wavelength</li><li><code>pp_ex=nothing</code>:      This is a required named parameter, containing all the settings for the excitation PSF. This should include the excitation wavelength as well as typically <code>aplanatic=aplanatic_illumination</code>.</li><li><code>pinhole=nothing</code>:   The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). By default (pinholes=nothing) the pinhole size is automatically calculated by the <code>pinhole_dist</code> parameter below to yield mutually touching pinholes.</li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due toundersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.</li><li><code>return_amp=false</code>:    Has to be <code>false</code> since confocal amplitude spread functions do not exist for non-zero pinhole sizes. </li><li><code>pinhole_positions=nothing</code>:  A list of pinhole positions. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.</li><li><code>pinhole_dist=0.5</code>: a value or tuple specified the distances between pinholes, when arranged in a grid. </li><li><code>pinhole_ft=box_pinhole_ft</code>:  Specifies which function is used to calculate the Fourier transform of the pinhole. This allows the user to control the pinhole shape. E.g. hexagonal pattern with round pinholes</li><li><code>pinhole_positions=nothing</code>:  Specifies the precise positions of the pinholes in the detection pathway. Be careful, since this is not the same as the position of the relative shift of the images.</li></ul><pre><code class="language-jdoctest hljs">julia&gt; sz=(128,128,128); sampling = (0.04,0.04,0.120)
julia&gt; pp_em = PSFParams(0.5,1.4,1.52; mode=ModeISM);
julia&gt; pp_ex = PSFParams(pp_em; λ=0.488, aplanatic=aplanatic_illumination);
julia&gt; p_ism = psf(sz,pp_em; pp_ex=pp_ex, pinhole=0.21, pinhole_dist=0.2, sampling=sampling);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PSFs.jl/blob/27e86deac40a0fc160f728e14562bc139455fc87/src/PSFs.jl#L239-L263">source</a></section><section><div><pre><code class="nohighlight hljs">psf(::Type{Mode2Photon}, sz::NTuple, pp_ex::PSFParams; pp_em=nothing, pinhole=nothing, sampling=nothing, pinhole_ft=disc_pinhole_ft, args...)
Calculates a 2-photon (potentially confocal) point spread function.  
Returns the PSF or a vector of PSFs.</code></pre><p>#Parameters</p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_ex</code>:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set <code>pp.aplanatic=aplanatic_illumination</code>.</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. This only needs to be supplied, if a pinhole is used. Otherwise non-descanned detection (NDD) is assumed.</li><li><code>pinhole=nothing</code>:   If <code>nothing</code>, NDD is assumed and the PSF is only the square of the excitation PSF. The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). </li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>use_resampling=true</code>: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due toundersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.</li><li><code>return_amp=false</code>:    Has to be <code>false</code> since confocal amplitude spread functions do not exist for non-zero pinhole sizes. </li><li><code>pinhole_positions=nothing</code>:  A list of pinhole positions. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.</li></ul><pre><code class="language-jdoctest hljs">julia&gt; sz=(128,128,128); sampling = (0.04,0.04,0.120)
julia&gt; pp_ex = PSFParams(0.8,1.4,1.52; mode=Mode2Photon, aplanatic= aplanatic_illumination);
julia&gt; p_2p = psf(sz,pp_ex; sampling=sampling);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PSFs.jl/blob/27e86deac40a0fc160f728e14562bc139455fc87/src/PSFs.jl#L282-L302">source</a></section><section><div><pre><code class="nohighlight hljs">psf(::Type{Mode4Pi}, sz::NTuple, pp_ex::PSFParams; sampling=nothing, pp_ex2=pp_ex, pp_em=nothing, pp_em2=nothing, rel_ex_phase = 0.0, rel_em_phase = 0.0, pinhole=nothing, pinhole_ft=disc_pinhole_ft, pinhole_positions=[(0.0,0.0)], ex2p=false)
Calculates a 4Pi point spread function. 
Returns the PSF or a vector of PSFs.</code></pre><p>#Parameters</p><ul><li><code>sz</code>:         size tuple of the final PSF</li><li><code>pp_ex</code>:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set <code>pp.aplanatic=aplanatic_illumination</code>.</li><li><code>pp_ex2</code>:     PSF parameters of the other side excitation PSF. If <code>nothing</code> is provided, single-sided excitation (e.g. 4Pi Type B) is assumed.</li><li><code>ex2p=true</code>:  If <code>true</code>, two-photon exciation is assumed.</li><li><code>pp_em</code>:      PSF parameters of the emission PSF. This only needs to be supplied, if a pinhole is used.</li><li><code>pp_em2</code>:     PSF parameters of the other side emission PSF. If <code>nothing is supplied, Type A 4Pi microscopy is assumed with single-sided (or incoherent) detection.</code></li><li><code>pinhole=nothing</code>:   If <code>nothing</code>, NDD is assumed and the PSF is only the square of the excitation PSF. The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). </li><li><code>sampling=nothing</code>:   The sampling parameters of the resulting PSF.</li><li><code>pinhole_positions=nothing</code>:  A list of pinhole positions. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.</li></ul><pre><code class="language-jdoctest hljs">julia&gt; sampling = (0.04,0.04,0.04)
julia&gt; sz = (128,128,128)
julia&gt; pp_em = PSFParams(0.5,1.3,1.52; mode=Mode4Pi, pol=pol_x);
julia&gt; pp_ex = PSFParams(0.800,1.3,1.52; aplanatic=aplanatic_illumination, mode=Mode4Pi, pol=pol_x);
julia&gt; @time p_4pi = psf(sz,pp_ex; pp_ex2=pp_ex, pp_em=pp_em, pp_em2=pp_em, sampling=sampling, pinhole=2.0, ex2p=true);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PSFs.jl/blob/27e86deac40a0fc160f728e14562bc139455fc87/src/PSFs.jl#L311-L334">source</a></section><section><div><pre><code class="nohighlight hljs">psf(sz::NTuple, pp::PSFParams; sampling=get_sampling(sz, pp))</code></pre><p>calculates the point spread function (psf), i.e. the image of a single (very small) emitter. Most of the parameters (such as refractive index, numerical aperture, vacuum wavelength, aberrations etc.) are hidden in the parameter structure argument <code>pp</code>, which should be generated via the <code>PSFParams()</code> constructor. See `<code>PSFParams()</code> for details. Note that the field <code>pp.mode</code> defines the microscopic mode to simulate. Currently implemented are the default <code>ModeWidefield</code> and <code>ModeConfocal</code>.</p><p>See also:</p><ul><li>apsf():  calculates the underlying amplitude point spread function (apsf)</li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; pp = PSFParams(0.5,1.4,1.52);
julia&gt; p = psf((128,128,128),pp; sampling=(0.050,0.050,0.200));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PSFs.jl/blob/27e86deac40a0fc160f728e14562bc139455fc87/src/PSFs.jl#L396-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PSFs.apsf" href="#PSFs.apsf"><code>PSFs.apsf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apsf(::Type{MethodParaxial}, sz::NTuple, pp::PSFParams; sampling=nothing) 
Calculates a paraxial amplitude PSF. Typically `pp.polarization` should be `pol_scalar`. However, other polarisation types yield two channels in the 4th dimension.
One for X and one for Y polarisation. In the paraxial approximation there is no Z polarisation.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PSFs.jl/blob/27e86deac40a0fc160f728e14562bc139455fc87/src/aPSFs.jl#L1-L5">source</a></section><section><div><pre><code class="nohighlight hljs">apsf(sz::NTuple, pp::PSFParams; sampling=nothing, center_kz=false)</code></pre><p>dispatches to various amplitude point spread function calculation routines. Note that the <code>method</code> entry in <code>pp</code> defines which calculation method to be used. Alternatively a different method can be chosen like this: <code>apsf(::Type{MethodShell}, sz, ..)</code>.</p><p>Arguments:</p><ul><li>sz: NTuple of size to generate</li><li>pp: PSF parameter structure, also contains the dtype. See PSFParam() for details</li><li>sampling: NTuple for pixel pitch information</li><li>center_kz: if true, the McCutchen pupil will be centered along the kz direction. This is important to be able to apply a consecutive resampling without errors.            However, the phase values are then not correct, which does not matter for intensity PSFs.</li></ul><p>See also:</p><ul><li>psf():    calculates the intensity point spread function (psf) by taking (sum along field components of) the absolute square of the corresponding apsf. </li></ul><p>Example:</p><pre><code class="language-jdoctest hljs">julia&gt; pp = PSFParams(500.0,1.4,1.52)
julia&gt; p = apsf((128,128,128),pp; sampling=(50,50,100));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RainerHeintzmann/PSFs.jl/blob/27e86deac40a0fc160f728e14562bc139455fc87/src/aPSFs.jl#L377-L399">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PSF_parameters/">« PSF parameters</a><a class="docs-footer-nextpage" href="../../function_references/all_functions/">List of Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 4 July 2022 08:12">Monday 4 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
