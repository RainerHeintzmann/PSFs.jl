var documenterSearchIndex = {"docs":
[{"location":"workflow/PSF_generation/#PointSpreadFunction-calculation","page":"PointSpreadFunction calculation","title":"PointSpreadFunction calculation","text":"","category":"section"},{"location":"workflow/PSF_generation/","page":"PointSpreadFunction calculation","title":"PointSpreadFunction calculation","text":"PointSpreadFunctions.psf\nPointSpreadFunctions.apsf","category":"page"},{"location":"workflow/PSF_generation/#PointSpreadFunctions.psf","page":"PointSpreadFunction calculation","title":"PointSpreadFunctions.psf","text":"psf(::Type{ModeWidefield}, sz::NTuple, pp::PSFParams; sampling=get_sampling(sz, pp))\n\nCalculates the widefield single-frequency point spread function (psf), i.e. the image of a single (very small) emitter.  Most of the parameters (such as refractive index, numerical aperture, vacuum wavelength, aberrations etc.) are hidden in the  parameter structure argument pp, which should be generated via the PSFParams() constructor. See `PSFParams() for details.\n\nParameters\n\nsz:         size tuple of the final PSF\npp:         PSF parameters of the PSF. See PSFParams() for details. The argument pp.aplanatic defined whether an excitation or emission PSF is calculated.\nsampling=nothing:   The sampling parameters of the resulting PSF. If nothing is provided, the PSF will be sampled according to the Abbe limit.\nuse_resampling=true: Exploits a calculation trick, which first calculates the amplitudes are calculated on a twice coarser grid and the result is upsampled. This increases the speed but may be less accurate.\nreturn_amp=false:    Has to be false since confocal amplitude spread functions do not exist for non-zero pinhole sizes. \n\nSee also:\n\napsf:  calculates the underlying amplitude point spread function (apsf)\n\nExample:\n\njulia> pp = PSFParams(0.5,1.4,1.52); sz=(128,128,128); sampling=(0.050,0.050,0.200);\n# an emission PSF of an isotropic (freely rotating emitter)\n\njulia> p_wf = psf(sz, pp; sampling=sampling);\n# an emission PSF of an emitter oriented along the Z direction\n\njulia> pp_dipole = PSFParams(0.5,1.4,1.52; transition_dipole=[0.0,0.0,1.0]);\n\njulia> p_dipole = psf(sz, pp_dipole; sampling=sampling);\n\n\n\n\n\npsf(::Type{ModeConfocal}, sz::NTuple, pp_em::PSFParams; pp_ex=nothing, pinhole=nothing, pinhole_ft=disc_pinhole_ft, sampling=nothing, use_resampling=true, return_amp=false, pinhole_positions=[(0.0,0.0)], ex_modifier=modify_ident) # unclear why the resampling seems to be so bad\n\nCalculates a confocal point spread function. The normalisation is such that a completely open pinhole diameter yields the excitation PSF with its normalization.  Returns the PSF or a vector of PSFs.\n\nParameters\n\nsz:         size tuple of the final PSF\npp_em:      PSF parameters of the emission PSF. PSF parameters of the PSF. See PSFParams() for details. This should include the emission wavelength\npp_ex=nothing:      This is a required named parameter, containing all the settings for the excitation PSF. This should include the excitation wavelength as well as typically aplanatic=aplanatic_illumination.\npinhole=nothing:    The diameter of the pinhole in Airy Units (AU = 1.22 λ/NA). A pinhole size of one AU corresponds to a pinhole border falling onto the first zero of a corresponding paraxial emission PSF.\nsampling=nothing:   The sampling parameters of the resulting PSF.\nuse_resampling=true: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due to undersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.\nreturn_amp=false:    Has to be false since confocal amplitude spread functions do not exist for non-zero pinhole sizes. \npinhole_positions=[(0.0,0.0)]:  A list of pinhole positions in pixels. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs. Specifies the precise position(s) of the pinholes in the detection path. This allows to simulate an offset (misadjusted) pinhole, or (as a vector of tuples) a PSF for a whole set of positions. See the psf(ModeISM, ...) for more details. \npinhole_ft=disc_pinhole_ft:  Specifies which function is used to calculate the Fourier transform of the pinhole. This allows the user to control the pinhole shape. \nex_modifier:   A function that can modify the excitation PSF. By default the identity is used, but other options are modify_square to calculate a two-photon confocal PSF. However, you should typically use the Mode2Photon to do this. Note that the order of the PSFParams are reversed.   By default (modify_ident), no modication is performed.\n\njulia> pp_em = PSFParams(0.5,1.4,1.52; mode=ModeConfocal);\njulia> pp_ex = PSFParams(pp_em; λ=0.488, aplanatic=aplanatic_illumination);\njulia> p_conf = psf((128,128,128),pp_em; pp_ex=pp_ex, pinhole=0.1, sampling=(0.040,0.040,0.100));\n\n\n\n\n\npsf(::Type{ModeLightsheet}, sz::NTuple, pp_em::PSFParams; pp_ex=nothing, sampling=nothing, use_resampling=true, dynamically_scanned=false) # unclear why the resampling seems to be so bad\n\nCalculates a point spread function for a lightsheet microscopy. Not that the coordinate system refers to the detection PSF. The NA of the  excitation PSF refers to the Z and Y direction. The polarisation of the excitation PSF along X means along Z and along Y means along Y in the final volume. Note that the excitation is assumed for the best focus position (beam waist). In reality the PSF will be spatially dependent due to the excitation focus.\n\nParameters\n\nsz:         size tuple of the final PSF\npp_em:      PSF parameters of the emission PSF. PSF parameters of the PSF. See PSFParams() for details. This should include the emission wavelength\npp_ex=nothing:      This is a required named parameter, containing all the settings for the excitation PSF. This should include the excitation wavelength as well as typically aplanatic=aplanatic_illumination.\npinhole=nothing:    The diameter of the pinhole in Airy Units (AU = 1.22 λ/NA). A pinhole size of one AU corresponds to a pinhole border falling onto the first zero of a corresponding paraxial emission PSF.\nsampling=nothing:   The sampling parameters of the resulting PSF.\nuse_resampling=true: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due to undersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.\n'dynamically_scanned': specifies, whether the lightsheet uses a dynamically scanned beam. This is important for the calculation of the PSF. If the beam is scanned, the PSF will be calculated in the same way as for a confocal PSF. If the beam is not scanned, the excitation PSF will be assuming a focussing via a cylinder lens.\nex_modifier:   A function that can modify the excitation PSF. By default the identity is used, but other options are modify_square to calculate a two-photon confocal PSF. However, you should typically use the Mode2Photon to do this. Note that the order of the PSFParams are reversed.   By default (modify_ident), no modication is performed.\nsigmaz = nothing: If the user provides a sigmaz value, the excitation calculation is using a Guassian excitation PSF with the specified sigma. pp_ex is ignored.\n\njulia> pp_em = PSFParams(0.5,0.9,1.33; mode=ModeLightsheet);\njulia> pp_ex = PSFParams(0.488, 0.2, 1.33);\njulia> p_lightsheet = psf((128,128,128), pp_em; pp_ex=pp_ex, sampling=(0.040,0.040,0.100), dynamically_scanned=true);\njulia> p_lightsheet_gauss = psf((128,128,128), pp_em; sampling=(0.040,0.040,0.100), sigma_z=1.0); # Gaussian excitation PSF\n\n\n\n\n\npsf(::Type{ModeISM}, sz::NTuple, pp_em::PSFParams; pinhole=nothing, sampling=nothing, pinhole_ft=box_pinhole_ft, pinhole_positions=[(0.0,0.0)], pinhole_dist=0.5, pinhole_grid=(5,5), ism_pos=ism_positions_rect, args...)\n\nCalculates a confocal point spread function. The normalisation is such that a completely open pinhole diameter yields the excitation PSF with its normalization.  Returns the PSF or a vector of PSFs.\n\nParameters\n\nsz:         size tuple of the final PSF\npp_em:      PSF parameters of the emission PSF. This should include the emission wavelength\npp_ex=nothing:      This is a required named parameter, containing all the settings for the excitation PSF. This should include the excitation wavelength as well as typically aplanatic=aplanatic_illumination.\npinhole=nothing:   The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). By default (pinholes=nothing) the pinhole size is automatically calculated by the pinhole_dist parameter below to yield mutually touching pinholes.\nsampling=nothing:   The sampling parameters of the resulting PSF.\nuse_resampling=true: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due toundersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.\nreturn_amp=false:    Has to be false since confocal amplitude spread functions do not exist for non-zero pinhole sizes. \npinhole_positions=nothing:  A list of pinhole positions in pixel coordinates. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs. Be careful, since this is not the same as the position of the relative shift of the images.\npinhole_dist=0.5: a value or tuple specified the distances between pinholes, when arranged in a grid. \npinhole_ft=box_pinhole_ft:  Specifies which function is used to calculate the Fourier transform of the pinhole. This allows the user to control the pinhole shape. E.g. hexagonal pattern with round pinholes\n\njulia> sz=(128,128,128); sampling = (0.04,0.04,0.120)\njulia> pp_em = PSFParams(0.5,1.4,1.52; mode=ModeISM);\njulia> pp_ex = PSFParams(pp_em; λ=0.488, aplanatic=aplanatic_illumination);\njulia> p_ism = psf(sz,pp_em; pp_ex=pp_ex, pinhole=0.21, pinhole_dist=0.2, sampling=sampling);\n\n\n\n\n\npsf(::Type{Mode2Photon}, sz::NTuple, pp_ex::PSFParams; pp_em=nothing, pinhole=nothing, sampling=nothing, pinhole_ft=disc_pinhole_ft, args...)\n\nCalculates a 2-photon (potentially confocal) point spread function.   Returns the PSF or a vector of PSFs.\n\nParameters\n\nsz:         size tuple of the final PSF\npp_ex:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set pp.aplanatic=aplanatic_illumination.\npp_em:      PSF parameters of the emission PSF. This only needs to be supplied, if a pinhole is used. Otherwise non-descanned detection (NDD) is assumed.\npinhole=nothing:   If nothing, NDD is assumed and the PSF is only the square of the excitation PSF. The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). \nsampling=nothing:   The sampling parameters of the resulting PSF.\nuse_resampling=true: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due toundersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.\nreturn_amp=false:    Has to be false since confocal amplitude spread functions do not exist for non-zero pinhole sizes. \npinhole_positions=[(0.0,0.0)]:  A list of pinhole positions in pixels. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.\n\njulia> sz=(128,128,128); sampling = (0.04,0.04,0.120)\njulia> pp_ex = PSFParams(0.8,1.4,1.52; mode=Mode2Photon, aplanatic= aplanatic_illumination);\njulia> p_2p = psf(sz,pp_ex; sampling=sampling);\n\n\n\n\n\npsf(::Type{ModeSTED}, sz::NTuple, pp_ex::PSFParams, pp_sted::PSFParams; pp_em=nothing, pinhole=nothing, sampling=nothing, pinhole_ft=disc_pinhole_ft, args...)\n\nCalculates a 2-photon (potentially confocal) point spread function.   Returns the PSF or a vector of PSFs.\n\nParameters\n\nsz:         size tuple of the final PSF\npp_ex:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set pp.aplanatic=aplanatic_illumination.\npp_sted:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set pp.aplanatic=aplanatic_illumination.\npp_em:      PSF parameters of the emission PSF. This only needs to be supplied, if a pinhole is used. Otherwise non-descanned detection (NDD) is assumed.\npinhole=nothing:   If nothing, NDD is assumed and the PSF is only the square of the excitation PSF. The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). \nsampling=nothing:   The sampling parameters of the resulting PSF.\nuse_resampling=true: Exploits a calculation trick, which first calculates the individual PSFs on a twice coarser grid in XY and Z and then upsamples the result. Note that this may be inappropriate due toundersampling due to the Stokes shift which is neglected here. But warnings will then result during the calculations of the subsampled widefield PSFs.\nreturn_amp=false:    Has to be false since confocal amplitude spread functions do not exist for non-zero pinhole sizes. \npinhole_positions=[(0.0,0.0)]:  A list of pinhole positions in pixels. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.\n\njulia> sz=(128,128,128); sampling = (0.04,0.04,0.120)\njulia> pp_em = PSFParams(0.510,1.4,1.52; mode=ModeSTED); # STED suppression beam\njulia> pp_ex = PSFParams(0.488,1.4,1.52; aplanatic= aplanatic_illumination);\njulia> pp_sted = PSFParams(0.570,1.4,1.52; method=MethodPropagateIterative, aplanatic= aplanatic_illumination, pol=pol_circ_spiral);\njulia> p_sted_01 = psf(sz, pp_em; pp_ex=pp_ex, pinhole= 2.0, sampling=sampling, pp_sted=pp_sted, rel_sted_intensity=0.1);\njulia> p_sted_1 = psf(sz, pp_em; pp_ex=pp_ex, pinhole= 2.0, sampling=sampling, pp_sted=pp_sted, rel_sted_intensity=1.0);\njulia> p_sted_5 = psf(sz, pp_em; pp_ex=pp_ex, pinhole= 2.0, sampling=sampling, pp_sted=pp_sted, rel_sted_intensity=5.0);\njulia> pp_sted_b = PSFParams(0.570,1.4,1.52; method=MethodPropagateIterative, aplanatic= aplanatic_illumination, pol=pol_circ_tophat);\njulia> p_sted_b5 = psf(sz, pp_em; pp_ex=pp_ex, pinhole= 2.0, sampling=sampling, pp_sted=pp_sted_b, rel_sted_intensity=5.0);\njulia> using View5D; @vt p_sted_01 p_sted_1 p_sted_5 p_sted_b5\n\n\n\n\n\npsf(::Type{Mode4Pi}, sz::NTuple, pp_ex::PSFParams; sampling=nothing, pp_ex2=pp_ex, pp_em=nothing, pp_em2=nothing, rel_ex_phase = 0.0, rel_em_phase = 0.0, pinhole=nothing, pinhole_ft=disc_pinhole_ft, pinhole_positions=[(0.0,0.0)], ex_modifier=modify_square)\n\nCalculates a 4Pi point spread function. Note that the default is using a two-photon excitation. Returns the PSF or a vector of PSFs.\n\nParameters\n\nsz:         size tuple of the final PSF\npp_ex:      PSF parameters of the excitation PSF. This should include the exission wavelength (typically in the IR region). Please make sure to also set pp.aplanatic=aplanatic_illumination.\npp_ex2:     PSF parameters of the other side excitation PSF. If nothing is provided, single-sided excitation (e.g. 4Pi Type B) is assumed.\nex_modifier=modify_square:  If modify_square, two-photon excitation is assumed. Use modify_ident for single-photon excitation.\npp_em:      PSF parameters of the emission PSF. This only needs to be supplied, if a pinhole is used.\npp_em2:     PSF parameters of the other side emission PSF. If nothing is supplied, Type A 4Pi microscopy is assumed with single-sided (or incoherent) detection.\npinhole=nothing:   If nothing, NDD is assumed and the PSF is only the square of the excitation PSF. The diameter of each pinhole in Airy Units (AU = 1.22 λ/NA). \nsampling=nothing:   The sampling parameters of the resulting PSF.\npinhole_positions=[(0.0,0.0)]:  A list of pinhole positions in pixels. One PSF will be returned for each pinhole position. If only a single pinhole position is supplied the PSF will directly be returned instead of a vector of PSFs.\n\njulia> sampling = (0.04,0.04,0.04)\njulia> sz = (128,128,128)\njulia> pp_em = PSFParams(0.5,1.3,1.52; mode=Mode4Pi, pol=pol_x);\njulia> pp_ex = PSFParams(0.800,1.3,1.52; aplanatic=aplanatic_illumination, mode=Mode4Pi, pol=pol_x);\njulia> @time p_4pi = psf(sz,pp_ex; pp_ex2=pp_ex, pp_em=pp_em, pp_em2=pp_em, sampling=sampling, pinhole=2.0, ex_modifier=modify_square);\n\n\n\n\n\npsf(sz::NTuple, pp::PSFParams; sampling=get_sampling(sz, pp))\n\nCalculates the point spread function (psf), i.e. the image of a single (very small) emitter. Most of the parameters (such as refractive index, numerical aperture, vacuum wavelength, aberrations etc.) are hidden in the parameter structure argument pp, which should be generated via the PSFParams() constructor. See `PSFParams() for details. Note that the field pp.mode defines the microscopic mode to simulate. Currently implemented are the default ModeWidefield and ModeConfocal.\n\nSee also:\n\napsf():  calculates the underlying amplitude point spread function (apsf)\n\nExample:\n\njulia> pp = PSFParams(0.5,1.4,1.52);\njulia> p = psf((128,128,128),pp; sampling=(0.050,0.050,0.200));\n\n\n\n\n\n","category":"function"},{"location":"workflow/PSF_generation/#PointSpreadFunctions.apsf","page":"PointSpreadFunction calculation","title":"PointSpreadFunctions.apsf","text":"apsf(::Type{MethodParaxial}, sz::NTuple, pp::PSFParams; sampling=nothing) \nCalculates a paraxial amplitude PSF. Typically `pp.polarization` should be `pol_scalar`. However, other polarisation types yield two channels in the 4th dimension.\nOne for X and one for Y polarisation. In the paraxial approximation there is no Z polarisation.\n\n\n\n\n\napsf(sz::NTuple, pp::PSFParams; sampling=nothing, center_kz=false)\n\ndispatches to various amplitude point spread function calculation routines. Note that the method entry in pp defines which calculation method to be used. Alternatively a different method can be chosen like this: apsf(::Type{MethodShell}, sz, ..).\n\nArguments:\n\nsz: NTuple of size to generate\npp: PSF parameter structure, also contains the dtype. See PSFParam() for details\nsampling: NTuple for pixel pitch information\ncenter_kz: if true, the McCutchen pupil will be centered along the kz direction. This is important to be able to apply a consecutive resampling without errors.            However, the phase values are then not correct, which does not matter for intensity PSFs.\n\nSee also:\n\npsf():    calculates the intensity point spread function (psf) by taking (sum along field components of) the absolute square of the corresponding apsf. \n\nExample:\n\njulia> pp = PSFParams(500.0,1.4,1.52)\njulia> p = apsf((128,128,128),pp; sampling=(50,50,100));\n\n\n\n\n\n","category":"function"},{"location":"workflow/PSF_parameters/#PointSpreadFunction-parameters","page":"PointSpreadFunction parameters","title":"PointSpreadFunction parameters","text":"","category":"section"},{"location":"workflow/PSF_parameters/","page":"PointSpreadFunction parameters","title":"PointSpreadFunction parameters","text":"PointSpreadFunctions.PSFParams\nPointSpreadFunctions.PSFParams(my_λ=500, my_NA=1.2, my_n=1.33; pol=pol_scalar, dtype=Float32, mode=ModeWidefield, \n                    aplanatic = aplanatic_detection, method=MethodPropagateIterative, FFTPlan=nothing,\n                    aberrations=Aberrations(), pixelshape=nothing)","category":"page"},{"location":"workflow/PSF_parameters/#PointSpreadFunctions.PSFParams","page":"PointSpreadFunction parameters","title":"PointSpreadFunctions.PSFParams","text":"PSFParams\n\nThis structure stores all the general parameters needed to calculate the point spread function. Only pixel-pitch and image size information is handles seperately.\n\nStructure Members:\n\nλ:            Vacuum wavelength\nNA:           numerical aperture\nn:            refractive index of the embedding AND immersion medium\ndtype:        real-valued data type to generate PSF for\nmode:         microscopy mode to calculate PSF for. See the constructor PSFParams() for more details.\npolarization: a function calculating the polarization from a given Tuple of relative-k pupil vectors. The constructur argument is pol.\naplanatic:    aplanatic factor. Provided as a function of angle θ\nmethod:       the method of calculation\nFFTPlan:      information on how to calculate the FFTW plan\n\nSee also:\n\nPSFParams()\n\nExample:\n\njulia> using FFTW, PointSpreadFunctions\n\njulia> ppm = PSFParams(0.580, 1.4, 1.518;pol=pol_scalar,method=PointSpreadFunctions.MethodRichardsWolf, aberrations= aberr, FFTPlan=FFTW.MEASURE)\nPSFParams(0.58, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var\"#42#43\"(), PointSpreadFunctions.MethodSincR, 0x00000000, nothing, nothing)\n\n\n\n\n\n\n","category":"type"},{"location":"workflow/PSF_parameters/#PointSpreadFunctions.PSFParams-2","page":"PointSpreadFunction parameters","title":"PointSpreadFunctions.PSFParams","text":"PSFParams(λ=0.5, NA=1.2, n=1.33; pol=pol_circ, dtype=Float32, mode=ModeWidefield, \naplanatic = aplanatic_detection, method=MethodRichardsWolf, FFTPlan=nothing,\naberrations=Aberrations(), pixelshape=nothing, transition_dipole=nothing, λ_weights=nothing)\n\ncreates the PSFParams structure via this constructor. You can also call PSFParams with the first argument being an existing structure and just specify the parameters to change via one or multiple named arguments.\n\nArguments:\n\nλ:            Vacuum emsision wavelength (same units as sampling, default is 0.5 µm)\nNA:           numerical aperture\nn:            refractive index of the embedding AND immersion medium\npol:          a function calculating the polarization from a given Tuple of relative-k pupil vectors\ndtype:        real-valued data type to generate PSF for\nmode:         microscopy mode to calculate PSF for ::PSFMode. \nModeWidefield (default): Widefield microscopy\nMode2Photon: Two-photon microscopy\nMode4Pi: 4Pi microscopy\nModeConfocal: Confocal microscopy\nModeISM: Image scanning microscopy\nModeSTED: stimulated emission depletion microscopy\nModeLSCylinder: Light-sheet microscopy illuminating with a cylindrical lens\nModeDSLM: Dynamically scanned light-sheet microscopy\nmethod:         microscopy mode to calculate PSF for                valid options are currently:\nMethodPropagate: Angulare spectrum propagation. This version does NOT account for wrap around problems yielding problems at larger out-of-focus distances\nMethodPropagateIterativ (default): Angulare spectrum propagation accounting from wrap-around problems in each propagation step by applying a perfectly matched layer (PML).\nMethodShell: Angulare spectrum propagation with a slightly different calculation order. This version does NOT account for wrap around problems yielding problems at larger out-of-focus distances\nMethodSincR: Based on first calculating a SincR function in real space and applying consecutive filtering steps. It accounts for wrap around problems but requires a quite high sampling along the Z direction.\nMethodRichardsWolf: Uses the method described in the paper by B. Richards and E. Wolf, \"Electromagnetic diffraction in optical systems. II. structure of the image field in an aplanatic system,\" Proc. R. Soc. London A, vol. 253, no. 1274, 1959.                       The terms I0, I1 and I2 are first calculated for an radial Z-dependet profile and then interpolated onto the 3D volume.\naplanatic:    aplanatic factor. Provided as a function of angle θ. Choices are aplanatic_const, aplanatic_detection, aplanatic_illumination, aplanatic_illumination_flux\nFFTPlan:      information on how to calculate the FFTW plan. Default: nothing (using FFTW.ESTIMATE)\ntransition_dipole  If supplied a transition-dipole (e.g. sqrt(2) .* (0.0,1.0,1.0)) will be accounted for in the PSF calculation. If not normalized, the strength will be included.\n\nExample:\n\njulia> using FFTW, PointSpreadFunctions\n\njulia> ppm = PSFParams(0.58, 1.4, 1.518;pol=pol_circ,method=PointSpreadFunctions.MethodSincR, aberrations= Aberrations(), FFTPlan=FFTW.MEASURE)\nPSFParams(0.58, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var\"#42#43\"(), PointSpreadFunctions.MethodSincR, 0x00000000, nothing, nothing)\n\njulia> ppem = PSFParams(ppm; λ=0.620)\n\n\n\n\n\n\n","category":"type"},{"location":"workflow/PSF_parameters/#Defining-Aberrations","page":"PointSpreadFunction parameters","title":"Defining Aberrations","text":"","category":"section"},{"location":"workflow/PSF_parameters/","page":"PointSpreadFunction parameters","title":"PointSpreadFunction parameters","text":"PointSpreadFunctions.Aberrations","category":"page"},{"location":"workflow/PSF_parameters/#PointSpreadFunctions.Aberrations","page":"PointSpreadFunction parameters","title":"PointSpreadFunctions.Aberrations","text":"Aberrations\ndefining Zernike phase aberrations via a list of indices and coefficients and an indexing style.\n\n\n\n\n\n","category":"type"},{"location":"function_references/all_functions/#List-of-Functions","page":"List of Functions","title":"List of Functions","text":"","category":"section"},{"location":"function_references/all_functions/#Parameters","page":"List of Functions","title":"Parameters","text":"","category":"section"},{"location":"function_references/all_functions/","page":"List of Functions","title":"List of Functions","text":"see Workflow","category":"page"},{"location":"function_references/all_functions/#PointSpreadFunction-generation","page":"List of Functions","title":"PointSpreadFunction generation","text":"","category":"section"},{"location":"function_references/all_functions/","page":"List of Functions","title":"List of Functions","text":"see Workflow","category":"page"},{"location":"function_references/all_functions/#Pupils","page":"List of Functions","title":"Pupils","text":"","category":"section"},{"location":"function_references/all_functions/","page":"List of Functions","title":"List of Functions","text":"PointSpreadFunctions.pupil_θ(sz, pp::PSFParams, sampling)\nPointSpreadFunctions.pupil_ϕ(sz, pp::PSFParams, sampling)\naplanatic_factor(sz, pp::PSFParams, sampling)\npupil_xyz(sz, pp, sampling=nothing)\nPointSpreadFunctions.field_xyz(sz, pp, sampling)\nPointSpreadFunctions.field_xy_to_xyz(field,pp,sampling)\nPointSpreadFunctions.field_pupil\nPointSpreadFunctions.get_propagator(sz,pp,sampling)\nPointSpreadFunctions.get_propagator_gradient(prop_phase, scalar, xy_scale)\nPointSpreadFunctions.apply_propagators(pupil, z_planes, pp::PSFParams; sampling=nothing) \nPointSpreadFunctions.get_zernike_pupil_phase(sz, pp, sampling) \nPointSpreadFunctions.get_zernike_pupil(sz, pp, sampling) ","category":"page"},{"location":"function_references/all_functions/#PointSpreadFunctions.pupil_θ-Tuple{Any, PSFParams, Any}","page":"List of Functions","title":"PointSpreadFunctions.pupil_θ","text":"pupil_θ(sz, pp::PSFParams, sampling)\n\nreturns the θ angle (to the optical axis) in the sample space as a pupil array.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.pupil_ϕ-Tuple{Any, PSFParams, Any}","page":"List of Functions","title":"PointSpreadFunctions.pupil_ϕ","text":"pupil_ϕ(sz, pp::PSFParams, sampling)\n\nreturns the azimuthal angle ϕ  in the sample space as a pupil array.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.aplanatic_factor-Tuple{Any, PSFParams, Any}","page":"List of Functions","title":"PointSpreadFunctions.aplanatic_factor","text":"aplanatic_factor(sz, pp::PSFParams, sampling)\n\nreturns the aplanatic factor as specified in pp.aplanatic as a pupil array.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.pupil_xyz","page":"List of Functions","title":"PointSpreadFunctions.pupil_xyz","text":"pupil_xyz(sz, pp, sampling=nothing)\n\ncreates a pupil with electric field distributions in XYZ. Returns a 4D dataset with the electric field components along the 4th dimension. #Arguments\n\n'sz':     size of the pupil in pixels\n'pp':     the PSFParam structure with all the PSF parameters\n'sampling':   the pixel sampling in the same units as the wavelength\n'is_proj':    defines whether the pupil is to be interpreted as the projection of the McCutchen pupil or not. This yields a by 1 ./cos(Theta) modified aplanatic factor.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.field_xyz-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.field_xyz","text":"field_xyz(sz, pp, sampling)\n\ncreates a 2D pupil field behind the lens, containing Ex, EY and E_z.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.field_xy_to_xyz-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.field_xy_to_xyz","text":"field_xy_to_xyz(field,pp,sampling)\n\nconverts a 2D field at the pupil to a 2D field behind the lens, containing Ex, EY and E_z.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.field_pupil","page":"List of Functions","title":"PointSpreadFunctions.field_pupil","text":"field_pupil(sz, pp, sampling)\n\nreturns the pupil polarization as a 4D array with the XY polarization components stacked along the 4th dimension.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.get_propagator-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.get_propagator","text":"get_propagator(sz,pp,sampling)\n\nretrieves the propagator phase, prpagating a single Z-slice.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.get_propagator_gradient-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.get_propagator_gradient","text":"get_propagator_gradient(prop_phase, scalar, xy_scale)\n\ncalculates the gradient of the propagator along the X and Y directions of the pupil.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.apply_propagators-Tuple{Any, Any, PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.apply_propagators","text":"apply_propagators(pupil, z_planes, pp::PSFParams; sampling=nothing)\n\npropagates a given pupil by a number of z_planes (almost) symmetrically in both directions. The result is a stack of propagated pupils. The slice-to-slice propagator is obtained via the get_propagator method.\n\nSee also:\n\nget_propagator\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.get_zernike_pupil_phase-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.get_zernike_pupil_phase","text":"get_zernike_pupil_phase(sz, pp, sampling)\n\ncalculates the phases in the pupil for a given set of aberrations as defined by J and coefficients. By default this follows the OSA nomenclature. See the help file of ZernikePolynomials.jl for more information. The pupil phase (up to the pupil border as defined by the NA in pp) is returned.\n\nArguments:\n\nsz:  size of the real-space array\npp:  PSF parameter structure\nsampling: pixelpitch in real space as NTuple\n\nExample:\n\njulia> using PointSpreadFunctions, FFTW\n\njulia> aberr = PointSpreadFunctions.Aberrations([Zernike_Spherical, Zernike_ObliqueAstigmatism],[0.1, 0.2])\nAberrations([12, 3], [0.1, 0.2], :OSA)\n\njulia> pp = PSFParams(580.0, 1.4, 1.518; aberrations=aberr)\nPSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var\"#42#43\"(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations([12, 3], [0.1, 0.2], :OSA), nothing)\n\njulia> sz = (10,10,64)\n(10, 10, 64)\n\njulia> sampling=(190,190,100)\n(190, 190, 100)\n\njulia> PointSpreadFunctions.get_zernike_pupil_phase(sz,pp,sampling)\n10×10 Matrix{Float64}:\n 0.0   0.0         0.0         0.0         0.0         0.0         0.0         0.0         0.0         0.0\n 0.0   0.0         0.0         0.533599    0.202003   -0.0206203  -0.170662   -0.21173     0.0         0.0\n 0.0   0.0         0.477274    0.186398    0.0287554  -0.104828   -0.250743   -0.3726     -0.361221    0.0\n 0.0   0.533599    0.186398    0.0937363   0.0736565   0.016983   -0.112676   -0.278928   -0.3726     -0.21173\n 0.0   0.202003    0.0287554   0.0736565   0.154747    0.162853    0.0615812  -0.112676   -0.250743   -0.170662\n 0.0  -0.0206203  -0.104828    0.016983    0.162853    0.223607    0.162853    0.016983   -0.104828   -0.0206203\n 0.0  -0.170662   -0.250743   -0.112676    0.0615812   0.162853    0.154747    0.0736565   0.0287554   0.202003\n 0.0  -0.21173    -0.3726     -0.278928   -0.112676    0.016983    0.0736565   0.0937363   0.186398    0.533599\n 0.0   0.0        -0.361221   -0.3726     -0.250743   -0.104828    0.0287554   0.186398    0.477274    0.0\n 0.0   0.0         0.0        -0.21173    -0.170662   -0.0206203   0.202003    0.533599    0.0         0.0\n\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.get_zernike_pupil-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.get_zernike_pupil","text":"get_zernike_pupil(sz, pp, sampling)\n\ncalculates the phases in the pupil for a given set of aberrations as defined by J and coefficients. By default this follows the OSA nomenclature. See the help file of ZernikePolynomials.jl for more information. The complex-valued pupil (up to the pupil border as defined by the NA in pp) is returned.\n\nArguments:\n\nsz:  size of the real-space array\npp:  PSF parameter structure\nsampling: pixelpitch in real space as NTuple\n\nExample:\n\njulia> using PointSpreadFunctions, FFTW\n\njulia> aberr = PointSpreadFunctions.Aberrations([Zernike_Spherical, Zernike_ObliqueAstigmatism],[0.1, 0.2])\nAberrations([12, 3], [0.1, 0.2], :OSA)\n\njulia> pp = PSFParams(580.0, 1.4, 1.518; aberrations=aberr)\nPSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var\"#42#43\"(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations([12, 3], [0.1, 0.2], :OSA), nothing)\n\njulia> sz = (10,10,64)\n(10, 10, 64)\n\njulia> sampling=(190,190,100)\n(190, 190, 100)\n\njulia> PointSpreadFunctions.get_zernike_pupil(sz,pp,sampling)\n10×10 Matrix{ComplexF64}:\n 1.0+0.0im        1.0+0.0im               1.0+0.0im             1.0+0.0im               1.0+0.0im       …          1.0+0.0im             1.0+0.0im               1.0+0.0im             1.0+0.0im\n 1.0+0.0im        1.0+0.0im               1.0+0.0im       -0.977799-0.209546im     0.297025+0.95487im         0.478105-0.878303im   0.238146-0.971229im          1.0+0.0im             1.0+0.0im\n 1.0+0.0im        1.0+0.0im         -0.989823+0.142305im   0.389073+0.921207im     0.983723+0.179694im     -0.00466964-0.999989im  -0.696362-0.717691im    -0.643318-0.765599im        1.0+0.0im\n 1.0+0.0im  -0.977799-0.209546im     0.389073+0.921207im   0.831518+0.555499im     0.894807+0.446453im        0.759688-0.650288im  -0.180764-0.983527im    -0.696362-0.717691im   0.238146-0.971229im\n 1.0+0.0im   0.297025+0.95487im      0.983723+0.179694im   0.894807+0.446453im     0.563395+0.826187im        0.926073+0.377344im   0.759688-0.650288im  -0.00466964-0.999989im   0.478105-0.878303im\n 1.0+0.0im   0.991619-0.129199im     0.790818-0.612051im   0.994312+0.106505im     0.520607+0.853797im  …     0.520607+0.853797im   0.994312+0.106505im     0.790818-0.612051im   0.991619-0.129199im\n 1.0+0.0im   0.478105-0.878303im  -0.00466964-0.999989im   0.759688-0.650288im     0.926073+0.377344im        0.563395+0.826187im   0.894807+0.446453im     0.983723+0.179694im   0.297025+0.95487im\n 1.0+0.0im   0.238146-0.971229im    -0.696362-0.717691im  -0.180764-0.983527im     0.759688-0.650288im        0.894807+0.446453im   0.831518+0.555499im     0.389073+0.921207im  -0.977799-0.209546im\n 1.0+0.0im        1.0+0.0im         -0.643318-0.765599im  -0.696362-0.717691im  -0.00466964-0.999989im        0.983723+0.179694im   0.389073+0.921207im    -0.989823+0.142305im        1.0+0.0im\n 1.0+0.0im        1.0+0.0im               1.0+0.0im        0.238146-0.971229im     0.478105-0.878303im        0.297025+0.95487im   -0.977799-0.209546im          1.0+0.0im             1.0+0.0im\n\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#Polarization","page":"List of Functions","title":"Polarization","text":"","category":"section"},{"location":"function_references/all_functions/","page":"List of Functions","title":"List of Functions","text":"These functions can be conveniently supplied to PSFParams() via the named argument polarization ","category":"page"},{"location":"function_references/all_functions/","page":"List of Functions","title":"List of Functions","text":"pol_scalar\npol_scalar_spiral\npol_x\npol_y\npol_circ\npol_circ_spiral","category":"page"},{"location":"function_references/all_functions/#PointSpreadFunctions.pol_scalar","page":"List of Functions","title":"PointSpreadFunctions.pol_scalar","text":"pol_scalar(T, xypos)\n\nignores polarization aspects in the calculation but calculates only based on (high-NA) scalar theory. This is a lot faster but not as accurate.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.pol_scalar_spiral","page":"List of Functions","title":"PointSpreadFunctions.pol_scalar_spiral","text":"pol_scalar_spiral(T, xypos)\n\nignores polarization aspects in the calculation but calculates only based on (high-NA) scalar theory. This version still includes a (scalar) phase spiral. This is a lot faster but not as accurate.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.pol_x","page":"List of Functions","title":"PointSpreadFunctions.pol_x","text":"pol_x(T, xypos)\n\nassumes x-polarization in illumination or an x-oriented polarizer in detection.  In a high-NA objective this is converted into XYZ electric fields at the focus.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.pol_y","page":"List of Functions","title":"PointSpreadFunctions.pol_y","text":"pol_y(T, xypos)\n\nassumes y-polarization in illumination or an x-oriented polarizer in detection.  In a high-NA objective this is converted into XYZ electric fields at the focus.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.pol_circ","page":"List of Functions","title":"PointSpreadFunctions.pol_circ","text":"pol_circ(T, xypos)\n\nassumes circular polarization in illumination or an x-oriented polarizer in detection.  In a high-NA objective this is converted into XYZ electric fields at the focus.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.pol_circ_spiral","page":"List of Functions","title":"PointSpreadFunctions.pol_circ_spiral","text":"pol_circ_spiral(T, xypos)\n\nassumes circular polarization in illumination or an x-oriented polarizer in detection.  This version includes phase spiral defining the local (xypos-dependent) phase of both x and y polarization.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#Aplanatic-factors","page":"List of Functions","title":"Aplanatic factors","text":"","category":"section"},{"location":"function_references/all_functions/","page":"List of Functions","title":"List of Functions","text":"aplanatic_detection\naplanatic_illumination\naplanatic_const\naplanatic_illumination_flux","category":"page"},{"location":"function_references/all_functions/#PointSpreadFunctions.aplanatic_detection","page":"List of Functions","title":"PointSpreadFunctions.aplanatic_detection","text":"aplanatic_detection = (θ) -> sqrt.(max.(0,cos.(θ)))\n\nThis is the aplanatic factor typically used in detection of fluorescence of (randomly oriented) fluorophores. \n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.aplanatic_illumination","page":"List of Functions","title":"PointSpreadFunctions.aplanatic_illumination","text":"aplanatic_illumination = (θ) -> sqrt.(max.(0,cos.(θ)))\n\nThis is the aplanatic factor typically used in illumination of (randomly oriented) fluorophores. Note that it is identical to detection.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.aplanatic_const","page":"List of Functions","title":"PointSpreadFunctions.aplanatic_const","text":"aplanatic_const = (θ) -> one.(eltype(θ))\n\nThis is a constant aplanatic factor\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#PointSpreadFunctions.aplanatic_illumination_flux","page":"List of Functions","title":"PointSpreadFunctions.aplanatic_illumination_flux","text":"aplanatic_illumination_flux = (θ) -> max.(0,cos.(θ))\n\nThis refers the aplanatic factor if interested in the flux through a detector perpendicular to the optical axis.\n\n\n\n\n\n","category":"function"},{"location":"function_references/all_functions/#Utilities","page":"List of Functions","title":"Utilities","text":"","category":"section"},{"location":"function_references/all_functions/","page":"List of Functions","title":"List of Functions","text":"PointSpreadFunctions.amp_to_int(field)\nPointSpreadFunctions.has_z_symmetry(pp::PSFParams)\nPointSpreadFunctions.get_Abbe_limit(pp::PSFParams)\nPointSpreadFunctions.get_required_amp_sampling(sz::NTuple, pp::PSFParams)\nPointSpreadFunctions.get_Ewald_sampling(sz::NTuple, pp::PSFParams)\nPointSpreadFunctions.get_McCutchen_kz_center(sz, pp::PSFParams, sampling)\nPointSpreadFunctions.limit_kz(ft_shell, pp::PSFParams, sampling)\nPointSpreadFunctions.sinc_r(sz::NTuple, pp::PSFParams; sampling=nothing)\nPointSpreadFunctions.jinc_r_2d(sz::NTuple, pp::PSFParams; sampling=nothing)\nPointSpreadFunctions.my_disc(sz, pp)\nPointSpreadFunctions.iftz(arr)\nPointSpreadFunctions.theta_z(sz)\nPointSpreadFunctions.k_0(pp::PSFParams)\nPointSpreadFunctions.k_pupil(pp::PSFParams)\nPointSpreadFunctions.k_dz(pp::PSFParams)\nPointSpreadFunctions.k_scale(sz, pp::PSFParams, sampling)\nPointSpreadFunctions.k_pupil_pos(sz, pp::PSFParams, sampling)\nPointSpreadFunctions.k_0_pos(sz, pp::PSFParams, sampling)\nPointSpreadFunctions.k_r(sz, pp::PSFParams, sampling)\nPointSpreadFunctions.k_xy(sz,pp,sampling)\nPointSpreadFunctions.k_xy_rel_pupil(sz,pp,sampling)\nPointSpreadFunctions.check_amp_sampling_xy(sz, pp,sampling)\nPointSpreadFunctions.check_amp_sampling_z(sz, pp,sampling)\nPointSpreadFunctions.check_amp_sampling(sz, pp,sampling)\nPointSpreadFunctions.check_amp_sampling_sincr(sz, pp,sampling)","category":"page"},{"location":"function_references/all_functions/#PointSpreadFunctions.amp_to_int-Tuple{Any}","page":"List of Functions","title":"PointSpreadFunctions.amp_to_int","text":"amp_to_int(field, pp)\n\nconverts a complex-valued amplitude field to intensity via abs2. and summing over the 4th dimension and dropping the 4th dimension. If pp.transition_dipole is provided, the dipole transition probability is calculated, otherwise a directionally independed effect is assumed.\n\n#Arguments\n\nfield:    The 4D field to extract the intensity from\npp:       Is checked for whether pp.transition_dipole is not nothing. \n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.has_z_symmetry-Tuple{PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.has_z_symmetry","text":"has_z_symmetry(pp::PSFParams)\n\nchecks whether the point spread function is expected to be symmetric along the z-direction. Currently this is defined by the aberration list being empty.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.get_Abbe_limit-Tuple{PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.get_Abbe_limit","text":"get_Abbe_limit(pp::PSFParams)\n\nreturns the Abbe limit of incoherent imaging in real space as a Tuple with 3 entries. Note that the coherent limit needs only a factor of two less sampling, as long as no intensity is calculated. This allows upsampling right before calculating intensities.\n\nSee also:\n\ngetrequiredamp_sampling()\n\nExample:\n\njulia> using PointSpreadFunctions\n\njulia> pp = PSFParams(580.0, 1.4, 1.518)\nPSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var\"#42#43\"(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations(Any[], Any[], :OSA), nothing)\n\njulia> PointSpreadFunctions.get_Abbe_limit(pp)\n(191.04085f0, 191.04085f0, 622.8464f0)\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.get_required_amp_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.get_required_amp_sampling","text":"get_required_amp_sampling(sz::NTuple, pp::PSFParams)\n\nreturns the necessary sampling (in real space) for sampling amplitudes. This is almost corresponding to the Abbe limit. Factor of two less because of amplitude but twice because of the Nyquist theorem.  However, this is slight modified by requiring slightly higher sampling (one empty pixel on each side of Fourier space) to stay clear of ambiguities.\n\nSee also:\n\ngetAbbelimit()\n\nExample:\n\njulia> using PointSpreadFunctions\n\njulia> pp = PSFParams(580.0, 1.4, 1.518)\nPSFParams(580.0, 1.4, 1.518, Float32, ModeWidefield, PointSpreadFunctions.pol_scalar, PointSpreadFunctions.var\"#42#43\"(), PointSpreadFunctions.MethodPropagateIterative, nothing, Aberrations(Any[], Any[], :OSA), nothing)\n\njulia> sz = (256,256,64)\n(256, 256, 64)\n\njulia> PointSpreadFunctions.get_required_amp_sampling(sz,pp)\n(188.05583f0, 188.05583f0, 219.73679f0)\n\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.get_Ewald_sampling-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.get_Ewald_sampling","text":"get_Ewald_sampling(sz::NTuple, pp::PSFParams)\n\nreturns the required minimum sampling for the calculation of a full Ewald sphere.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.get_McCutchen_kz_center-Tuple{Any, PSFParams, Any}","page":"List of Functions","title":"PointSpreadFunctions.get_McCutchen_kz_center","text":"get_McCutchen_kz_center(ft_shell, pp::PSFParams, sampling)\n\ncalculates the (rounded) pixels position half way between both, the kz-borders of the McCutchen pupil to extract from the full sized Ewald sphere. The pixel z position is returned together with the corresponding kz position.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.limit_kz-Tuple{Any, PSFParams, Any}","page":"List of Functions","title":"PointSpreadFunctions.limit_kz","text":"limit_k_z(ft_shell, pp::PSFParams, sampling)\n\nlimits the k_z range of the ewald-sphere. returns the extracted region and the new sampling\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.sinc_r-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.sinc_r","text":"sinc_r(sz::NTuple, pp::PSFParams; sampling=nothing)\n\ncalculates the 3-dimensional sinc(abs(position)) scaled such that the Fourier transformation yields the k-sphere. Note that for this to work the sampling needs to be sufficient, which may be problematic especially along the z-direction. This can be checked with the help of the get_Ewald_sampling() function.\n\nSee also:\n\ngetEwaldsampling()\njincr2d\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.jinc_r_2d-Tuple{Tuple{Vararg{T, N}} where {N, T}, PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.jinc_r_2d","text":"jinc_r_2d(sz::NTuple, pp::PSFParams; sampling=nothing)\n\ncalculates a jinc(abs(position)) function in 2D such that its Fourier transform corresponds to the disk-shaped pupil (indcluding the effect ot the numerical aperture). If sampling is not provided, sampling is assumed such that the Nyquist sampling would correspond to sampling the wavelength (i.e. the Ewals sphere) correctly for this amplitude.\n\nSee also:\n\nsinc_r()\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.my_disc-Tuple{Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.my_disc","text":"my_disc(sz, pp)\n\ncreates a disc such that there is no overalp upon wrap-around, when convolving it with itself on this grid. This is the radius where there is no overlap. However, in the cornes of the calculation, the results are not 100% accurate as something is missing.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.iftz-Tuple{Any}","page":"List of Functions","title":"PointSpreadFunctions.iftz","text":"iftz(arr)\n\ninverse Fourier transform only along the 3rd dimension (kz).\n\nArguments:\n\narr:  array to transform along kz\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.theta_z-Tuple{Any}","page":"List of Functions","title":"PointSpreadFunctions.theta_z","text":"theta_z(sz)\n\na θ function along the z direction, being one for z positon > 0 and zero elsewhere.\n\nArguments:\n\nsz:  size of the array\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.k_0-Tuple{PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.k_0","text":"k_0(pp::PSFParams)\n\nk in the medium as n/lambda.   (1/space units)\n\nArguments:\n\npp:  PSF parameter structure\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.k_pupil-Tuple{PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.k_pupil","text":"k_pupil(pp::PSFParams)\n\nmaxim radial (i.e. XY-) k-coordinate (1/space units) where the pupil ends\n\nArguments:\n\npp:  PSF parameter structure\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.k_dz-Tuple{PSFParams}","page":"List of Functions","title":"PointSpreadFunctions.k_dz","text":"k_dz(pp::PSFParams)\n\nrelative kz range from pupil boarder to top of Ewald sphere (in 1/space units)\n\nArguments:\n\npp:  PSF parameter structure\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.k_scale-Tuple{Any, PSFParams, Any}","page":"List of Functions","title":"PointSpreadFunctions.k_scale","text":"k_scale(sz,pp,sampling)\npixelpitch (as NTuple) in k-space\n\nsz:  size of the real-space array\npp:  PSF parameter structure\nsampling: pixelpitch in real space as NTuple\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.k_pupil_pos-Tuple{Any, PSFParams, Any}","page":"List of Functions","title":"PointSpreadFunctions.k_pupil_pos","text":"k_pupil_pos(sz, pp::PSFParams, sampling)\n\nreturns the X and Y position of the pupil border in reciprocal space pixels.\n\nArguments:\n\nsz:  size of the real-space array\npp:  PSF parameter structure\nsampling: pixelpitch in real space as NTuple\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.k_0_pos-Tuple{Any, PSFParams, Any}","page":"List of Functions","title":"PointSpreadFunctions.k_0_pos","text":"k_0_pos(sz, pp::PSFParams, sampling)\n\nreturns the X, Y and Z position of the Ewald-sphere border in reciprocal space pixels.\n\nArguments:\n\nsz:  size of the real-space array\npp:  PSF parameter structure\nsampling: pixelpitch in real space as NTuple\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.k_r-Tuple{Any, PSFParams, Any}","page":"List of Functions","title":"PointSpreadFunctions.k_r","text":"k_r(sz, pp::PSFParams, sampling)\n\nreturns an array of radial k coordinates, |k_xy|\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.k_xy-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.k_xy","text":"k_xy(sz,pp,sampling)\n\nyields a 2D array with each entry being a 2D Tuple.\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.k_xy_rel_pupil-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.k_xy_rel_pupil","text":"k_xy_rel_pupil(sz,pp,sampling)\n\nreturns an array of relative distance to the pupil border\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.check_amp_sampling_xy-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.check_amp_sampling_xy","text":"check_amp_sampling_xy(sz, pp,sampling)\n\nissues a warning if the amplitude sampling along X and Y is not within the required limits.\n\nSee also:\n\ngetAbbelimit()\ngetrequiredamp_sampling()\ncheckampsampling()\ncheckampsampling_z()\n\nArguments:\n\nsz:  size of the real-space array\npp:  PSF parameter structure\nsampling: pixelpitch in real space as NTuple\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.check_amp_sampling_z-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.check_amp_sampling_z","text":"check_amp_sampling_z(sz, pp,sampling)\n\nissues a warning if the amplitude sampling along Z is not within the required limits.\n\nSee also:\n\ngetAbbelimit()\ngetrequiredamp_sampling()\ncheckampsampling_xy()\ncheckampsampling()\n\nArguments:\n\nsz:  size of the real-space array\npp:  PSF parameter structure\nsampling: pixelpitch in real space as NTuple\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.check_amp_sampling-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.check_amp_sampling","text":"check_amp_sampling(sz, pp,sampling)\n\nissues a warning if the amplitude sampling (X,Y and Z) is not within the required limits.\n\nSee also:\n\ngetAbbelimit()\ngetrequiredamp_sampling()\ncheckampsampling_xy()\ncheckampsampling_z()\n\nArguments:\n\nsz:  size of the real-space array\npp:  PSF parameter structure\nsampling: pixelpitch in real space as NTuple\n\n\n\n\n\n","category":"method"},{"location":"function_references/all_functions/#PointSpreadFunctions.check_amp_sampling_sincr-Tuple{Any, Any, Any}","page":"List of Functions","title":"PointSpreadFunctions.check_amp_sampling_sincr","text":"check_amp_sampling_sincr(sz, pp,sampling)\n\nissues a warning if the amplitude sampling (X,Y and Z) is not within the required limits for the SincR method, as this requires sampling the Ewald-sphere according to Nyquist.\n\nSee also:\n\ngetAbbelimit()\ngetrequiredamp_sampling()\ncheckampsampling()\ngetEwaldsampling()\n\nArguments:\n\nsz:  size of the real-space array\npp:  PSF parameter structure\nsampling: pixelpitch in real space as NTuple\n\n\n\n\n\n","category":"method"},{"location":"#PSfs.jl-Documentation","page":"PointSpreadFunctions.jl","title":"PSfs.jl Documentation","text":"","category":"section"},{"location":"","page":"PointSpreadFunctions.jl","title":"PointSpreadFunctions.jl","text":"This toolbox aims at fast and accurate calculations of point spread functions (PSFs) as used in optics. It is particularyl suited for high numerical aperture PSfs and vectorial aspects of the electric field.  Aplanatic factors as for aplanatic optical systems fullfilling the Abbe sine condition are accounted for as well as various pupil properties can be supplied.  Different modes of calculation are possible and more will be added in the future. Aberrations can be specified in terms of Zernike coefficients.","category":"page"}]
}
